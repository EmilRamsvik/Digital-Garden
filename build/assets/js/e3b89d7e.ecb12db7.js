"use strict";(self.webpackChunkdigital_garden=self.webpackChunkdigital_garden||[]).push([[88846],{12108:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>g,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var t=i(85893),a=i(11151);const s={Finished:null,tags:["article","digital-garden","data-science","data-engineering","feature-engineering","encoding","embedding","one-hot-encoding"],created:"2024-01-06T15:04",updated:"2024-01-06T15:04"},r="Feature Engineering",o={id:"AI/Data Science/Feature Engineering",title:"Feature Engineering",description:"Dummy vs One-hot",source:"@site/docs/AI/Data Science/Feature Engineering.md",sourceDirName:"AI/Data Science",slug:"/AI/Data Science/Feature Engineering",permalink:"/docs/AI/Data Science/Feature Engineering",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/AI/Data Science/Feature Engineering.md",tags:[{label:"article",permalink:"/docs/tags/article"},{label:"digital-garden",permalink:"/docs/tags/digital-garden"},{label:"data-science",permalink:"/docs/tags/data-science"},{label:"data-engineering",permalink:"/docs/tags/data-engineering"},{label:"feature-engineering",permalink:"/docs/tags/feature-engineering"},{label:"encoding",permalink:"/docs/tags/encoding"},{label:"embedding",permalink:"/docs/tags/embedding"},{label:"one-hot-encoding",permalink:"/docs/tags/one-hot-encoding"}],version:"current",frontMatter:{Finished:null,tags:["article","digital-garden","data-science","data-engineering","feature-engineering","encoding","embedding","one-hot-encoding"],created:"2024-01-06T15:04",updated:"2024-01-06T15:04"},sidebar:"gardenSidebar",previous:{title:"Data Science Project Start-Up Phase",permalink:"/docs/AI/Data Science/Data Science Project Start-Up Phase"},next:{title:"ML Design Sprint",permalink:"/docs/AI/Data Science/ML Design Sprint"}},d={},l=[{value:"Dummy vs One-hot",id:"dummy-vs-one-hot",level:2},{value:"Ordinal Encoding",id:"ordinal-encoding",level:2},{value:"Hashing",id:"hashing",level:2},{value:"Embeddings",id:"embeddings",level:2},{value:"<strong>Label Encoding First:</strong>",id:"label-encoding-first",level:5},{value:"<strong>Followed by Embeddings:</strong>",id:"followed-by-embeddings",level:5},{value:"<strong>Why Use Both?</strong>",id:"why-use-both",level:5}];function c(e){const n={h1:"h1",h2:"h2",h5:"h5",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"feature-engineering",children:"Feature Engineering"}),"\n",(0,t.jsx)(n.h1,{id:"encoding",children:"Encoding"}),"\n",(0,t.jsx)(n.h2,{id:"dummy-vs-one-hot",children:"Dummy vs One-hot"}),"\n",(0,t.jsx)(n.p,{children:"There is a difference between dummy and one-hot encoding"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'One-hot encoding creates a binary column for each category, and each data point has exactly one "hot" (1) value.'}),"\n",(0,t.jsx)(n.li,{children:'Dummy encoding creates "n-1" binary columns for "n" categories, and each data point has a combination of 0s and 1s, with one category implicitly represented by all 0s.\nThis difference is subtle but important. When using machine learning models, it is best to use a one-hot encoding.'}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"ordinal-encoding",children:"Ordinal Encoding"}),"\n",(0,t.jsx)(n.p,{children:"Ordinal encoding is smart to use when there is some kind of systemic relationship between the values to be encoded. For example, if the size of the city might matter, you can adjust the ordinal encoding to be ranked by size. This might help the relationship. However, you could also just infer the size of the city as a feature in itself to not only imply the relationship. When doing machine learning, it might be smart to not only understand what the categories and features represent but also if any underlaid patterns affect the target."}),"\n",(0,t.jsx)(n.h2,{id:"hashing",children:"Hashing"}),"\n",(0,t.jsx)(n.h2,{id:"embeddings",children:"Embeddings"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Label Encoding"})," is like assigning each category a unique ID. Simple but can imply false numerical relationships."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Embeddings"})," are like giving each category a unique, learnable fingerprint. More complex but can capture deeper relationships and nuances."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Label encoding and embeddings are often used together, especially in the context of neural networks. Here's how they typically work in tandem:"}),"\n",(0,t.jsx)(n.h5,{id:"label-encoding-first",children:(0,t.jsx)(n.strong,{children:"Label Encoding First:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Neural networks, and in particular embedding layers, expect numerical input. However, they cannot directly process categorical variables (like strings of port names or vessel IDs)."}),"\n",(0,t.jsx)(n.li,{children:"Label encoding is a preprocessing step where each unique categorical value is converted into a unique integer. This transformation is necessary because embedding layers require numerical input."}),"\n"]}),"\n",(0,t.jsx)(n.h5,{id:"followed-by-embeddings",children:(0,t.jsx)(n.strong,{children:"Followed by Embeddings:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Once the categorical data is converted into integers via label encoding, these integers are used as indexes to lookup vectors in an embedding matrix."}),"\n",(0,t.jsx)(n.li,{children:"The embedding matrix is part of the neural network and is learned during the training process. Each row in the matrix corresponds to one category (represented by the integer from label encoding) and contains a vector that represents that category in a multi-dimensional space."}),"\n"]}),"\n",(0,t.jsx)(n.h5,{id:"why-use-both",children:(0,t.jsx)(n.strong,{children:"Why Use Both?"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dimensionality Reduction:"})," Embedding layers effectively reduce the dimensionality of the input space. If you have thousands of categories, one-hot encoding would create a very sparse and high-dimensional input vector. Embeddings condense this information into a much smaller and denser vector."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Capturing Relationships:"})," Embeddings can capture more complex relationships between categories, which is not possible with just label encoding."]}),"\n"]}),"\n",(0,t.jsx)(n.h1,{id:"links",children:"Links"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{}),"\n"]}),"\n",(0,t.jsx)(n.h1,{id:"thoughts",children:"Thoughts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>o,a:()=>r});var t=i(67294);const a={},s=t.createContext(a);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);