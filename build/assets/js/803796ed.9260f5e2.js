"use strict";(self.webpackChunkdigital_garden=self.webpackChunkdigital_garden||[]).push([[68822],{53833:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var i=t(85893),s=t(11151);const a={"Date Started":"Jun 16, 2023",tags:["article","nlp","machine-learning","natural-language","gpt","transformers","LLM","AI"],finished:null,created:"2024-01-06T15:04",updated:"2024-01-06T15:04"},r="NLP",o={id:"AI/Language/NLP or LLM",title:"NLP",description:"Natural Language Processing (NLP) is using machine learning techniques to work with text.",source:"@site/docs/AI/Language/NLP or LLM.md",sourceDirName:"AI/Language",slug:"/AI/Language/NLP or LLM",permalink:"/docs/AI/Language/NLP or LLM",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/AI/Language/NLP or LLM.md",tags:[{label:"article",permalink:"/docs/tags/article"},{label:"nlp",permalink:"/docs/tags/nlp"},{label:"machine-learning",permalink:"/docs/tags/machine-learning"},{label:"natural-language",permalink:"/docs/tags/natural-language"},{label:"gpt",permalink:"/docs/tags/gpt"},{label:"transformers",permalink:"/docs/tags/transformers"},{label:"LLM",permalink:"/docs/tags/llm"},{label:"AI",permalink:"/docs/tags/ai"}],version:"current",frontMatter:{"Date Started":"Jun 16, 2023",tags:["article","nlp","machine-learning","natural-language","gpt","transformers","LLM","AI"],finished:null,created:"2024-01-06T15:04",updated:"2024-01-06T15:04"},sidebar:"gardenSidebar",previous:{title:"Recommendation Systems",permalink:"/docs/AI/Data Science/Recommendation Systems"},next:{title:"Articles",permalink:"/docs/Articles/"}},l={},c=[{value:"Transfer learning",id:"transfer-learning",level:2},{value:"Transformers",id:"transformers",level:2},{value:"Using transformers",id:"using-transformers",level:3},{value:"HuggingFace Transformer Class",id:"huggingface-transformer-class",level:3},{value:"LangChain",id:"langchain",level:2},{value:"Outlines",id:"outlines",level:2},{value:"Summarization",id:"summarization",level:2},{value:"Sentiment Analysis",id:"sentiment-analysis",level:2},{value:"Classification",id:"classification",level:2},{value:"Named Entity Recognition",id:"named-entity-recognition",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"nlp",children:"NLP"}),"\n",(0,i.jsxs)(n.p,{children:["Natural Language Processing (NLP) is using machine learning techniques to work with text.\n",(0,i.jsx)(n.em,{children:"Natural language"})," is a language that has developed naturally in use (as\xa0contrasted\xa0with an artificial language or computer code)."]}),"\n",(0,i.jsx)(n.h2,{id:"transfer-learning",children:"Transfer learning"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The default learning rate for Adam is usually way too high for transfer learning, one thing you can do is have a decaying learning rate for the optimizer.  For example, you can use a learning rate based on a polynomial learning rate."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://huggingface.co/docs/transformers/training",children:"HuggingFace Course on fine-tuning a pre-trained model"})}),"\n",(0,i.jsx)(n.h2,{id:"transformers",children:"Transformers"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://arxiv.org/abs/1706.03762",children:(0,i.jsx)(n.em,{children:"Attention is all you need."})})," The first transformer model was based on attention mechanisms. The transformer does not use recurrence and convolutions."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Types of Transformer Models:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Encoders"}),": In the context of Transformer models, encoders take an input sequence and convert it into a series of representations that capture the contextual information from the sequence. Each encoder operates in parallel, processing the entire sequence at once, and the output is a set of vectors with the same length as the input. BERT is a good example of this type of model.\n",(0,i.jsx)(n.em,{children:"Tasks: Sentence classification, named entity recognition, extractive question answering"})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Decoders"}),": Decoders in Transformer models use the representations generated by the encoders to generate an output sequence. The decoders also operate in parallel, but they are autoregressive, meaning each output element is generated one at a time, using both the representations from the encoders and the previously generated elements. GPT-2 is a good example of this type of model.\n",(0,i.jsx)(n.em,{children:"Tasks: Text generation"})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Sequence-to-sequence"}),": Sequence-to-sequence (seq2seq) is a concept in machine learning where a model is trained to convert sequences from one domain (input) to sequences in another domain (output). In the context of Transformer models, this often involves an encoder transforming an input sequence into a context-sensitive representation, and a decoder generating an output sequence from that representation."]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The encoder takes care of understanding the sequence."}),"\n",(0,i.jsxs)(n.li,{children:["The decoder takes care of generating a sequence according to the understanding of the encoder.\n",(0,i.jsx)(n.em,{children:"Tasks: Summarization, translation, generative question answering"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"using-transformers",children:"Using transformers"}),"\n",(0,i.jsx)(n.p,{children:"The Transformers API in \ud83e\udd17 provides a solution for handling multiple sequences and sequences of different lengths. Batching is used to send multiple sequences through the model at once, allowing efficient computation. Padding is employed to ensure that sequences within a batch have the same length, with a special padding token added to shorter sequences. Attention masks are used to instruct the model to ignore the padding tokens during computation."}),"\n",(0,i.jsx)(n.p,{children:"Models have a maximum supported sequence length, typically around 512 or 1024 tokens. If longer sequences need to be processed, either a model with longer supported length can be used or the sequences can be truncated to fit within the maximum length. Truncation involves reducing the length of the sequences by removing tokens from the beginning or end."}),"\n",(0,i.jsxs)(n.p,{children:["An ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.a,{href:"https://huggingface.co/docs/transformers/glossary#attention-mask",children:"attention mask"})})," is a binary tensor used in Transformer models to indicate which tokens should be attended to (value of 1) and which tokens should be ignored (value of 0) during computation. It ensures that padding tokens or other irrelevant tokens do not influence the attention mechanism, allowing the model to focus on the meaningful parts of the input sequence."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"sequence length"})," refers to the number of tokens in a given input sequence. It determines the length of the input tensors and influences the computational resources required for processing the sequence."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"batch size"})," refers to the number of sequences that are processed simultaneously in parallel. It allows for efficient computation by utilizing parallelism and vectorized operations on modern hardware."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"hidden size"})," refers to the dimensionality of the hidden representations in the Transformer model. It determines the size of the intermediate and output tensors throughout the model layers and is a key factor in the model's capacity to capture complex patterns and dependencies in the input data. The hidden size can be very large (768 is common for smaller models, and in larger models, this can reach 3072 or more)."]}),"\n",(0,i.jsx)(n.h3,{id:"huggingface-transformer-class",children:"HuggingFace Transformer Class"}),"\n",(0,i.jsx)(n.p,{children:"The HuggingFace transformer module can be used to do quick NLP tasks."}),"\n",(0,i.jsx)(n.p,{children:"Examples of models that can be applied"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://huggingface.co/learn/nlp-course/chapter1/3?fw=pt#zero-shot-classification",children:"Zero-Shot Classification"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://huggingface.co/learn/nlp-course/chapter1/3?fw=pt#zero-shot-classification",children:"Text Generation"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://huggingface.co/learn/nlp-course/chapter1/3?fw=pt#named-entity-recognition",children:"Named Entity Recognition"}),"  Documentation on the named entity recognition can be found ",(0,i.jsx)(n.a,{href:"https://huggingface.co/dslim/bert-base-NER",children:"here"}),". It is basically a NERT model that can recognize locations (LOC), organizations (ORG), persons (PER), and Miscellaneous (MISC)."]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://huggingface.co/learn/nlp-course/chapter1/3?fw=pt#summarization",children:"Text Summarization"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"langchain",children:"LangChain"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://python.langchain.com/docs/get_started/introduction.html",children:"Official LangChain Documentation"})}),"\n",(0,i.jsx)(n.p,{children:"Langchain is a framework for Large Language Models (LLMs). It provides out-of-the-box functionality to build inference with LLMs. I have not delved too much into it as of yet."}),"\n",(0,i.jsx)(n.p,{children:'The "Chain" in LangChain is because it provides a framework for "chaining" large language models together or with other components.'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/eyurtsev/kor",children:"Kor Package for keyword extraction"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/eyurtsev/kor",children:"Youtube Turtorial on Kor"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.youtube.com/watch?v=2xxziIWmaSA&list=WL&index=17&ab_channel=GregKamradt%28DataIndy%29",children:"In depth Introduction to LangChain"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://minimaxir.com/2023/07/langchain-problem/",children:"Critique of LangChain"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"outlines",children:"Outlines"}),"\n",(0,i.jsx)(n.p,{children:"Outlines is a framework for parsing data and creating structured data from LLMs. The way it works is that things like regex act as a conditional check for matches and can also be used to generate templates for the LLM. LLMs work best when we can guide them in the prompt, and using tools like regex to filter the data makes the generation of data correct. This is an important feature that will probably dominate a lot of the work when it comes to LLMs."}),"\n",(0,i.jsxs)(n.p,{children:["I think it is very important to understand that less powerful models are not that useful in an outline context.\n",(0,i.jsx)(n.a,{href:"https://blog.normalcomputing.ai/posts/2023-07-27-regex-guided-generation/regex-guided-generation.html#making-guided-generation-possible",children:"Blog post from Outlines describing the background of Outline"}),"\n",(0,i.jsx)(n.a,{href:"https://github.com/normal-computing/outlines#efficient-regex-guided-generation",children:"Outlines GitHub and docs"}),"\n",(0,i.jsx)(n.a,{href:"https://news.ycombinator.com/item?id=37125118",children:"Hacker News discussions"}),"\n",(0,i.jsx)(n.a,{href:"https://youtu.be/yj-wSRJwrrc?si=eQGFoq8VSeZRDySS",children:"Pydantic Example"}),"  This is the instructor but is better i think than outlines."]}),"\n",(0,i.jsx)(n.h1,{id:"use-cases",children:"Use Cases"}),"\n",(0,i.jsx)(n.h2,{id:"summarization",children:"Summarization"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://huggingface.co/tasks/summarization",children:"Summarization Course"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"sentiment-analysis",children:"Sentiment Analysis"}),"\n",(0,i.jsx)(n.h2,{id:"classification",children:"Classification"}),"\n",(0,i.jsx)(n.h2,{id:"named-entity-recognition",children:"Named Entity Recognition"}),"\n",(0,i.jsx)(n.h1,{id:"links",children:"Links"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://huggingface.co/learn/nlp-course/chapter0/1?fw=pt",children:"Introduction Course on NLP from Hugging Face"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://huggingface.co/docs/transformers/glossary#attention-mask",children:"Glossary from HuggingFace"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/huggingface/accelerate/tree/main/examples",children:"HuggingFace Accelerate Examples Repo"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/hwchase17/chat-langchain",children:"LangChain"})," GitHub repo for using LLMs."]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://brev.dev/blog/fine-tuning-llama-2",children:"Fine Tune Llama 2"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://simonwillison.net/2023/Aug/3/weird-world-of-llms/",children:"Catching up on the weird world of LLM"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/sindresorhus/awesome-chatgpt",children:"Awesome ChatGPT prompts"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://agi-sphere.com/llama-guide/",children:"Beginners guide to LLAMA"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/travistangvh/ChatGPT-Data-Science-Prompts",children:"Data science Prompts"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://openai-tokenizer.netlify.app/",children:"OpenAI Tokenizer"})," Gives you the amount of tokens in a text."]}),"\n"]}),"\n",(0,i.jsx)(n.h1,{id:"thoughts",children:"Thoughts"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"HuggingFace actually uses the  \ud83e\udd17  emoji to refer to themselves. Kinda cute."}),"\n",(0,i.jsx)(n.li,{children:"The HuggingFace tokenizer is based on Rust for speed."}),"\n",(0,i.jsx)(n.li,{children:"HuggingFace both support Tensorflow and Pytorch, I wonder which one will win.  Maybe we will have some way of standardizing the models into a new and better module, with standard components. Maybe this is the HuggingFace killer feature? It is also the JAX framework which I do not know that much about."}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tf.keras.losses.SparceCategoricalCrossentropy()"}),"is the standard keras loss function for categorization."]}),"\n",(0,i.jsxs)(n.li,{children:["A model is called\xa0",(0,i.jsx)(n.em,{children:"zero-shot"}),"\xa0because you don\u2019t need to fine-tune the model on your data to use it. It can directly return probability scores for any list of labels you want!"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Think of LLms as mostly inscrutable artifacts, developing correspondingly sophisticated evaluations."}),"  - Andrej Karpathy"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>r});var i=t(67294);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);