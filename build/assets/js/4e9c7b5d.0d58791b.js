"use strict";(self.webpackChunkdigital_garden=self.webpackChunkdigital_garden||[]).push([[72429],{4034:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var t=i(85893),s=i(11151);const a={Pages:400,Author:"Lakshmanan Valliappa",finished:!0,tags:["books","digital-garden","machine-learning","#design-patterns","#data-science"],"Date Finished":new Date("2023-11-02T00:00:00.000Z"),created:"2024-01-06T15:04",updated:"2024-01-06T15:04"},r="\ud83d\ude80 The Book in 3 Sentences",o={id:"Books/Book Reviews/Machine Learning Design Patterns",title:"\ud83d\ude80 The Book in 3 Sentences",description:"This book is about machine learning design patterns and discussions around those\u2014concepts in machine learning for this. And therefore, it is a good reminder of the concepts and core tenants of machine learning.",source:"@site/docs/Books/Book Reviews/Machine Learning Design Patterns.md",sourceDirName:"Books/Book Reviews",slug:"/Books/Book Reviews/Machine Learning Design Patterns",permalink:"/docs/Books/Book Reviews/Machine Learning Design Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/Book Reviews/Machine Learning Design Patterns.md",tags:[{label:"books",permalink:"/docs/tags/books"},{label:"digital-garden",permalink:"/docs/tags/digital-garden"},{label:"machine-learning",permalink:"/docs/tags/machine-learning"},{label:"#design-patterns",permalink:"/docs/tags/design-patterns"},{label:"#data-science",permalink:"/docs/tags/data-science"}],version:"current",frontMatter:{Pages:400,Author:"Lakshmanan Valliappa",finished:!0,tags:["books","digital-garden","machine-learning","#design-patterns","#data-science"],"Date Finished":"2023-11-02T00:00:00.000Z",created:"2024-01-06T15:04",updated:"2024-01-06T15:04"},sidebar:"gardenSidebar",previous:{title:"\ud83d\ude80 The Book in 3 Sentences",permalink:"/docs/Books/Book Reviews/Letters to a Young Contrarian"},next:{title:"The Book in 3 Sentences",permalink:"/docs/Books/Book Reviews/Made to Stick"}},l={},h=[];function c(e){const n={em:"em",h1:"h1",li:"li",p:"p",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"-the-book-in-3-sentences",children:"\ud83d\ude80 The Book in 3 Sentences"}),"\n",(0,t.jsx)(n.p,{children:"This book is about machine learning design patterns and discussions around those\u2014concepts in machine learning for this. And therefore, it is a good reminder of the concepts and core tenants of machine learning."}),"\n",(0,t.jsx)(n.h1,{id:"-impressions",children:"\ud83c\udfa8 Impressions"}),"\n",(0,t.jsx)(n.p,{children:'It was a bit of a harder read than [[Designing Machine Learning Systems]], which is a bit harder to grasp and not as "profound" knowledge. Therefore, it is more difficult for me to give it a very strong recommendation.  Nevertheless, it is important to say that this is a good book.  When reading through the quotes, I realize that there were a lot of good insights from the book.'}),"\n",(0,t.jsx)(n.h1,{id:"\ufe0f-my-top--quotes",children:"\u270d\ufe0f My Top  Quotes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"At its core, machine learning is a process of building models that learn from data."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Gradient descent optimizers require more steps to converge as the curvature of the loss function increases. This is because the derivatives of features with larger relative magnitudes will tend to be larger as well, and so lead to abnormal weight updates. The abnormally large weight updates will require more steps to converge and thereby increase the computation load."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"\u201cCentering\u201d the data to lie in the [\u20131, 1] range makes the error function more spherical. Therefore, models trained with transformed data tend to converge faster and are, therefore faster/cheaper to train. In addition, the [\u20131, 1] range offers the highest floating point precision."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"This is called dummy coding. Because dummy coding is a more compact representation, it is preferred in statistical models that perform better when the inputs are linearly independent.  Modern machine learning algorithms, though, don\u2019t require their inputs to be linearly independent and use methods such as L1 regularization to prune redundant inputs. The additional degree of freedom allows the framework to transparently handle a missing input in production as all zeros:"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"The categorical variables have high cardinality. Instead of having feature vectors with three languages or seven days, we have feature vectors whose length is in the thousands to millions."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"After the model is placed into production, new hospitals might be built and new physicians hired. The model will be unable to make predictions for these, and so a separate serving infrastructure will be required to handle such cold-start problems."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Even with simple representations like one-hot encoding, it is worth anticipating the cold-start problem and explicitly reserving all zeros for out-of-vocabulary inputs."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"OUT-OF-VOCABULARY INPUT  Even if an airport with a handful of flights is not part of the training dataset, its hashed feature value will be in the range [0\u20139]. Therefore, there is no resilience problem during serving\u2014the unknown airport will get the predictions corresponding with other airports in the hash bucket. The model will not error out."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"It is true that hashing is lossy\u2014since we have 347 airports, an average of 35 airports will get the same hash bucket code if we hash it into 10 buckets. When the alternative is to discard the variable because it is too wide, though, a lossy encoding is an acceptable compromise."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Most design patterns involve some kind of a trade-off, and the Hashed Feature design pattern is no exception. The key trade-off here is that we lose model accuracy."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Do not choose Hashed Feature if you know the vocabulary beforehand, if the vocabulary size is relatively small (in the thousands is acceptable for a dataset with millions of examples), and if a cold start is not a concern."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Embeddings are a learnable data representation that maps high-cardinality data into a lower-dimensional space in such a way that the information relevant to the learning problem is preserved."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"A feature cross is a synthetic feature formed by concatenating two or more categorical features in order to capture the interaction between them."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"For this reason, it is advisable to pair feature crosses with L1 regularization, which encourages sparsity of features, or L2 regularization, which limits overfitting."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"This type of model approach is also useful when the numerical representation has an intuitive interpretation; for example, a latitude and longitude pair can be used instead of urban area predictions."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"For examples like this one, where the goal is primarily to suggest possible tags with less emphasis on getting the tag exactly right, a typical rule of thumb is to use n_specific_tag / n_total_examples as a threshold for each class."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"This approach is called one versus rest. In the case of the Stack Overflow example where we want to tag questions as TensorFlow, Python, and pandas, we\u2019d train an individual classifier for each of these three tags: Python or not, TensorFlow or not, and so forth."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"The irreducible error is the inherent error in the model resulting from noise in the dataset, the framing of the problem, or bad training examples, like measurement errors or confounding factors. Just as the name implies, we can\u2019t do much about irreducible error."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"The other two, the bias and the variance, are referred to as the reducible error, and here is where we can influence our model\u2019s performance. In short, the bias is the model\u2019s inability to learn enough about the relationship between the model\u2019s features and labels, while the variance captures the model\u2019s inability to generalize on new, unseen examples. A model with high bias oversimplifies the relationship and is said to be underfit. A model with high variance has learned too much about the training data and is said to be overfit."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"This also explains why bagging is typically less effective for more stable learners like k-nearest neighbors (kNN), naive Bayes, linear models, or support vector machines (SVMs) since the size of the training set is reduced through bootstrapping."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"The boosting algorithm works by iteratively improving the model to reduce the prediction error. Each new weak learner corrects for the mistakes of the previous prediction by modeling the residuals delta_i of each step. The final prediction is the sum of the outputs from the base learner and each of the successive weak learners,"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"By iteratively focusing on the hard-to-predict examples, boosting effectively decreases the bias of the resulting model."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Stacking can be thought of as an extension of simple model averaging where we train k models to completion on the training dataset, then average the results to determine a prediction. Simple model averaging is similar to bagging, but the models in the ensemble could be of different types, while for bagging, the models are of the same type."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Splitting an ML problem is usually a bad idea, since an ML model can/should learn combinations of multiple factors."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"In many classification situations, creating a neutral class can be helpful. For example, instead of training a binary classifier that outputs the probability of an event, train a three-class classifier that outputs disjoint probabilities for Yes, No, and Maybe. Disjoint here means that the classes do not overlap."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"The Rebalancing design pattern provides various approaches for handling datasets that are inherently imbalanced. By this we mean datasets where one label makes up the majority of the dataset, leaving far fewer examples of other labels."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Precision measures the percentage of positive classifications that were correct out of all positive predictions made by the model. Conversely, recall measures the proportion of actual positive examples that were identified correctly by the model. The biggest difference between these two metrics is the denominator used to calculate them. For precision, the denominator is the total number of positive class predictions made by our model. For recall, it is the number of actual positive class examples present in our dataset."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"By weighting classes, we tell our model to treat specific label classes with more importance during training."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Overfitting can happen if the model complexity is higher than can be afforded by the size and coverage of the dataset."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"One bit of intuition as to why this works comes from the Uniform Approximation Theorem of deep learning, which, loosely put, states that any function (and its derivatives) can be approximated by a neural network with at least one hidden layer and any \u201csquashing\u201d activation function, like sigmoid."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"There is no noise, so the labels are accurate for all instances.  You have the complete dataset at your disposal (you have all the examples there are). In this case, overfitting becomes interpolating the dataset."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"In addition, recent research indicates that double descent happens in a variety of machine learning problems, and therefore it is better to train longer rather than risk a suboptimal solution by stopping early. Two splits  Isn\u2019t the advice in the regularization section in conflict with the advice in the previous sections on early stopping or checkpoint selection?"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"A model that takes two weeks to train on GPUs can converge in hours on TPUs."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"For example, as accelerators (GPUs, FPGAs, TPUs, and so on) have gotten faster, I/O has become a significant bottleneck in ML training."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Because stateless components don\u2019t have any state, they can be shared by multiple clients."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"The solution to any problem in computer science is to add an extra level of indirection."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"The Feature Store design pattern simplifies the management and reuse of features across projects by decoupling the feature creation process from the development of models using those features."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"One of the key characteristics of operationalized models is automated workflow pipelines. The development stage of the ML life cycle is a multi-step process. Building pipelines to automate these steps enables more efficient workflows and repeatable processes that improve future model development, and allows for increased agility in solving problems that arise."})}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>o,a:()=>r});var t=i(67294);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);